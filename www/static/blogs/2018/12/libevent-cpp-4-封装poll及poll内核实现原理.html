<p>随着Linux的更新在linux-2.1.23版本中加入了poll机制，因为poll的加入导致select的实现变得基于poll了，本文在上一个版本的基础上在libevent-cpp中加入了对poll机制的封装。总的来说，主要介绍libevent-cpp poll机制以及Linux内核对poll机制的实现原理，另外还会介绍到内核中select实现因为poll而做的改变。</p>
<h2>读写事件管理及poll机制</h2><hr style="margin-left:40%; margin-right:40%;"/>
<h3>poll机制</h3>
<p>如下为<code>poll</code>库函数，接收的数据<code>struct pollfd *fds</code> 其实是一个<code>strucct pollfd</code> 类型的数组，<code>nfds</code>对应着数组中元素的个数，最后一个为超时。与select最大的区别在于将关注的文件描述符以及对应的事件都抽取出来整合成<code>struct pollfd</code>类型了，而select需要一个很大的文件描述符集合数组，而其中可能只有很少的几个描述符是我们关注的可能会有读写事件。所以从功能上来说<code>poll</code>其实是更高效的。</p>
<pre class="brush: c++;">
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
};
</pre>
<h3>poll_base 管理读写事件</h3>
<p>首先对于读写事件的管理，仍然采用select中用到的文件描述符与<code>rw_event *</code>的映射关系fd_map_rw，这次将它抽取出来放入<code>event_base</code>中，因为对于底层IO的封装子类都免不了需要文件描述符与事件的映射关系，另外poll机制中独有的数据结构就是<code>fd_map_poll</code>，这是文件描述符与<code>struct pollfd *</code>之间的映射。</p>
<pre class="brush: c++;">
class poll_base : public event_base
{
  private:
    std::map< int, struct pollfd *> fd_map_poll;
  public:
    // add del dispatch recalc
};

class event_base
{
  public:
	std::map< int, rw_event *> fd_map_rw;
	int _fds = 0; /* highest fd of added rw_event */
	int _fdsz = 0;
    // ...
};
</pre>
<p>首先对于 poll_base中读写事件的添加和删除，主要其实就是对两个映射内容的修改，首先读写事件加入的时候，需要new一个新的<code>struct pollfd</code>，并设置对应的成员，主要是文件描述符和事件类型events，事件类型需要根据<code>rw_event *ev</code>是否可读或可写来进行设置。在删除的时候同样是需要将两个映射结构中的相关内容进行删除，并释放之前new的<code>struct pollfd</code>的内容。</p>
<pre class="brush: c++;">
int poll_base::add(rw_event *ev)
{
    fd_map_rw[ev->_fd] = ev;
    struct pollfd *pfd = new struct pollfd;
    pfd->fd = ev->_fd;
    pfd->events = 0;
    pfd->revents = 0;
    fd_map_poll[ev->_fd] = pfd;
    if (ev->is_readable())
        pfd->events |= POLLIN;
    if (ev->is_writable())
        pfd->events |= POLLOUT;
    return 0;
}
int poll_base::del(rw_event *ev)
{
    delete fd_map_poll[ev->_fd];
    fd_map_poll.erase(ev->_fd);
    fd_map_rw.erase(ev->_fd);
    return 0;
}
</pre>
<p>然后就是<code>dispatch</code>的处理，首先针对传入的超时时间结构获取对应的微秒数之后作为poll接口的超时参数，另外还需要手动将<code>fd_map_poll</code>中的<code>struct pollfd</code> 数据抽取出来组成数组，然后作为poll的参数，nfds就是fd_map_poll的size。在返回之后，如果某个<code>struct pollfd</code>事件有改变，直接查看其<code>revents</code>成员就可以知道发生了什么事情，poll机制中一些关键的事件包括POLLHUP、POLLERR、POLLIN及POLLOUT，根据对应发生的事情就可以设置激活读写事是否可读或可写，然后激活在激活队列中进行处理。</p>
<pre class="brush: c++;">
int poll_base::dispatch(struct timeval *tv)
{
    // ...
    int sec = -1;
    if (tv)
        sec = tv->tv_sec * 1000 + (tv->tv_usec + 999) / 1000;

    int nfds = fd_map_poll.size();
    struct pollfd fds[nfds];
    int i = 0;
    for (const auto kv : fd_map_poll)
        fds[i++] = *kv.second;

    int res = poll(fds, nfds, sec);

    // ... 根据poll结果res判断是否处理超时、信号返回还是继续处理读写事件

    int what = 0;
    rw_event *ev;
    for (i = 0; i <  nfds; i++)
    {
        what = fds[i].revents;
        ev = fd_map_rw[fds[i].fd];
        if (what & &  ev)
        {
            /* if the file gets closed notify */
            if (what &  (POLLHUP | POLLERR))
                what |= POLLIN | POLLOUT;
            if ((what &  POLLIN) & &  ev->is_readable())
                ev->set_active_read();
            if ((what &  POLLOUT) & &  ev->is_writable())
                ev->set_active_write();

            if (ev->has_active_read() || ev->has_active_write())
            {
                if (!ev->is_persistent())
                    ev->del();
                ev->activate(1);
            }
        }
    }
}
</pre>
<h2>Linux内核poll机制实现原理</h2><hr style="margin-left:40%; margin-right:40%;"/>
<p>用户态的<code>poll</code>库函数通过系统调用转换到内核态对应着<code>fs/select.c</code>中的sys_poll函数，如下内核代码基于linux-2.1.23版本，从这一版本开始linux加入了poll机制。</p>
<h3>poll内核调用-sys_poll</h3>
<p>与之前提到的<code>sys_select</code>类似的是，sys_poll函数一开始做的也是将传入的用户太的数据如<code>struct pollfd</code>数组先通过<code>copy_from_user</code>函数给复制到内核区域，并给等待列表wait_table分配对应的内存，在处理好相关参数之后调用<code>do_poll</code>来真正执行poll操作。</p>
<pre class="brush: c++;">
asmlinkage int sys_poll(struct pollfd * ufds, unsigned int nfds, int timeout)
{
    int i, count, fdcount, err = -EINVAL;
	struct pollfd * fds, *fds1;
	poll_table wait_table;
	struct poll_table_entry *entry;

	lock_kernel(); // 从有些版本起，Linux内核允许抢占，所以需要加锁

	entry = (struct poll_table_entry *) __get_free_page(GFP_KERNEL);

	fds = (struct pollfd *) kmalloc(nfds*sizeof(struct pollfd), GFP_KERNEL);
	if (copy_from_user(fds, ufds, nfds*sizeof(struct pollfd))) {
		free_page((unsigned long)entry);
		kfree(fds);
		goto out;
	}

	// 处理timeout
	current->timeout = timeout;

	count = 0;
	wait_table.nr = 0;
	wait_table.entry = entry;

	fdcount = do_poll(nfds, fds, & wait_table); // 调用 do_poll

	current->timeout = 0;
	free_wait(& wait_table);
	free_page((unsigned long) entry);

	/* 将poll结果中的返回事件revents传回用户区 */
	fds1 = fds;
	for(i=0; i <  (int)nfds; i++, ufds++, fds++) {
		__put_user(fds->revents, & ufds->revents);
	}
	kfree(fds1);
    // 如果poll中没有发生任何读写等操作 并且 产生了非阻塞的信号
	if (!fdcount & &  (current->signal &  ~current->blocked))
		err = -EINTR;
	else
		err = fdcount;
out:
	unlock_kernel();
	return err;
}
</pre>
<h3>poll实现-do_poll函数</h3>
<p>如下为内核中的<code>do_poll</code>函数，从原理上与<code>do_select</code>其实并无二样，都是采用轮询的方式遍历文件描述符，只不过如下do_poll遍历 <code>struct pollfd</code>数组时只需要遍历可能发生事件的数组，而do_select则不一样，其实现上会遍历一个完整的描述符数组，即使这个数组里面的绝大多数描述符都没有注册事件。所以从效率上来说poll是比select要好的。</p>
<pre class="brush: c++;">
static int do_poll(unsigned int nfds, struct pollfd *fds, poll_table *wait)
{
	int count;
	struct file ** fd = current->files->fd;

	count = 0;
	for (;;) {
		unsigned int j;
		struct pollfd * fdpnt;

		current->state = TASK_INTERRUPTIBLE;
        /* 遍历fds数组，调用相应文件对应的底层驱动poll 函数获得mask */
		for (fdpnt = fds, j = 0; j <  nfds; j++, fdpnt++) {
			unsigned int i;
			unsigned int mask;
			struct file * file; //fd对应的文件

			mask = POLLNVAL;
			i = fdpnt->fd;
			if (i <  NR_OPEN & &  (file = fd[i]) != NULL) {
				mask = DEFAULT_POLLMASK;
				if (file->f_op & &  file->f_op->poll)
					mask = file->f_op->poll(file, wait); //调用底层驱动的poll
				mask & = fdpnt->events | POLLERR | POLLHUP;
			}
			if (mask) { // mask非0，代表某些事件发生了
				wait = NULL;
				count++;
			}
			fdpnt->revents = mask;
		}

		wait = NULL;
        // 如果发生了某些读写等事件 或 已经超时 或 出现了非阻塞的信号 则跳出循环
		if (count || !current->timeout || (current->signal &  ~current->blocked))
			break;
		schedule(); // 重新调度，释放cpu
	}
	current->state = TASK_RUNNING;
	return count;
}
</pre>
<p>如上代码中，循环遍历fds中执行的关键操作还是调用底层的驱动函数poll，它会返回该文件描述符对应的文件是否有事件发生。之后判断整个数组是否有事件发生，如果有事件发生或者已经超时或者出现了非阻塞的信号，那么就跳出循环不再继续等待，否则调用<code>schedule</code>进行重新调度，并释放cpu。并且当前进程已经被设置为可中断状态TASK_INTERRUPTIBLE，这个进程设置为某些文件的等待队列，当这些文件出现了读写事件或者超时或者出现了信号时，这个进程会被唤醒，继续轮询。</p>
<h2>加入poll机制后select实现的变化</h2><hr style="margin-left:40%; margin-right:40%;"/>
<p>在加入了poll机制后，linux内核中对于底层驱动的接口事实上舍弃了原先的<code>select</code>底层函数，如下为linux-2.1.23版本的<code>struct file_operations</code>结构，其中对于文件的操作由<code>poll</code>替代了<code>select</code>，这么做也是有一定道理的，poll的可扩展性比select是要好的，而两者在原理上其实类似，都是采用轮询描述符的方式，只不过poll直接轮询的是注册事件的描述符，而select轮询的是从0到最大注册描述符之间的所有描述符。</p>
<pre class="brush: c++;">
struct file_operations {
	long long (*llseek) (struct inode *, struct file *, long long, int);
	long (*read) (struct inode *, struct file *, char *, unsigned long);
	long (*write) (struct inode *, struct file *, const char *, unsigned long);
	int (*readdir) (struct inode *, struct file *, void *, filldir_t);
	unsigned int (*poll) (struct file *, poll_table *);
	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
	int (*mmap) (struct inode *, struct file *, struct vm_area_struct *);
	int (*open) (struct inode *, struct file *);
	void (*release) (struct inode *, struct file *);
	int (*fsync) (struct inode *, struct file *);
	int (*fasync) (struct inode *, struct file *, int);
	int (*check_media_change) (kdev_t dev);
	int (*revalidate) (kdev_t dev);
};
</pre>
<h3>基于poll的do_select实现</h3>
<p>如下为基于poll文件操作的<code>do_select</code>的实现，唯一变化的就是在调用底层函数时调用的是poll，先根据设置过的文件描述符获取对应的文件结构，然后根据文件调用底层poll，后面根据获得的mask来分析是否退出就和上述的<code>do_poll</code>如出一辙了。</p>
<pre class="brush: c++;">
static int do_select(int n, fd_set_buffer *fds)
{
    // ...参数处理
	wait_table.nr = 0;
	wait_table.entry = entry;
	wait = & wait_table;
	for (;;) {
		struct file ** fd = current->files->fd;
		current->state = TASK_INTERRUPTIBLE;
		for (i = 0 ; i <  n ; i++,fd++) {
			unsigned long bit = BIT(i);
			unsigned long *in = MEM(i,fds->in);

			if (bit &  BITS(in)) {
				struct file * file = *fd;
				unsigned int mask = POLLNVAL;
				if (file) {
					mask = DEFAULT_POLLMASK;
					if (file->f_op & &  file->f_op->poll)
						mask = file->f_op->poll(file, wait); // 调用底层poll
				}
				if ((mask &  POLLIN_SET) & &  ISSET(bit, __IN(in))) {
					SET(bit, __RES_IN(in));
					retval++;
					wait = NULL;
				}
                // ... out ex
			}
		}
		wait = NULL;
		if (retval || !current->timeout || (current->signal &  ~current->blocked))
			break;
		schedule();
	}
	free_wait(& wait_table);
	free_page((unsigned long) entry);
	current->state = TASK_RUNNING;
out:
	return retval;
}
</pre>
<h2>小结</h2><hr style="margin-left:40%; margin-right:40%;"/>
<ul><li>1. libevent-cpp 中对于poll的封装</li>
<li>2. Linux内核poll及select代码分析基于linux-2.1.23版本</li>
</ul>
